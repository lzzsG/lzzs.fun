### 函数声明

在C语言中，函数声明是在函数定义之前告诉编译器该函数的返回类型和参数类型。这样，编译器可以在程序的其他部分调用该函数时进行类型检查。此代码中声明了几个函数，它们分别执行基本的算术运算（`add`、`subtract`、`multiply`、`divide`）以及一个检查条件的函数（`check_condition`）。

```c
int add(int a, int b);
int subtract(int a, int b);
int multiply(int a, int b);
int divide(int a, int b);
int check_condition(int num);
```

### 示例1：`if-else` 语句

`if-else` 语句用于根据条件的真伪执行不同的代码块。此示例中，通过比较变量 `a` 和 `b` 的值，决定输出哪条语句。如果 `a > b`，输出 `a 大于 b`，否则输出 `a 小于或等于 b`。

```c
if (a > b)
{
    printf("a 大于 b\n");
}
else
{
    printf("a 小于或等于 b\n");
}
```

**输出示例**：

```
if-else 语句:
a 小于或等于 b
```

### 示例2：嵌套的 `if-else` 语句

此示例展示了嵌套的 `if-else` 语句。如果第一个 `if` 条件为假，还可以在 `else` 部分继续嵌套更多的 `if` 语句。该示例用于进一步比较 `a` 和 `b`，并根据不同的比较结果输出相应的信息。

```c
if (a == b)
{
    printf("a 等于 b\n");
}
else
{
    if (a > b)
    {
        printf("a 大于 b\n");
    }
    else
    {
        printf("a 小于 b\n");
    }
}
```

**输出示例**：

```
嵌套的 if-else 语句:
a 小于 b
```

### 示例3：`else-if` 链

`else-if` 链是 `if-else` 语句的扩展形式，允许多个条件依次进行判断。此示例根据分数 `score` 输出不同的成绩等级：90分以上为A，80-89为B，70-79为C，其余为D。

```c
if (score >= 90)
{
    printf("成绩等级为 A\n");
}
else if (score >= 80)
{
    printf("成绩等级为 B\n");
}
else if (score >= 70)
{
    printf("成绩等级为 C\n");
}
else
{
    printf("成绩等级为 D\n");
}
```

**输出示例**：

```
else-if 链:
成绩等级为 B
```

### 示例4：`switch` 语句

`switch` 语句用于处理多重条件判断，通常用于对单个变量的多个值进行比较。此例中，`day` 变量表示星期几，`switch` 语句根据 `day` 的值输出相应的星期名称。`default` 分支用来处理不符合任何 `case` 条件的情况。

```c
switch (day)
{
    case 1:
        printf("今天是星期一\n");
        break;
    case 2:
        printf("今天是星期二\n");
        break;
    case 3:
        printf("今天是星期三\n");
        break;
    case 4:
        printf("今天是星期四\n");
        break;
    case 5:
        printf("今天是星期五\n");
        break;
    default:
        printf("周末\n");
        break;
}
```

**输出示例**：

```
switch 语句:
今天是星期二
```

### 示例5：三元运算符

三元运算符 `? :` 是一种简洁的条件判断语句，通常用于简单的条件赋值。此例中，通过 `a > b` 的结果判断 `max` 是 `a` 还是 `b`。

```c
int max = (a > b) ? a : b;
printf("a 和 b 中的最大值是: %d\n", max);
```

**输出示例**：

```
三元运算符:
a 和 b 中的最大值是: 20
```

### 示例6：`while` 循环

`while` 循环用于在条件为真时重复执行代码块。此示例展示了一个计数器 `count`，它从 0 开始，每次循环结束后自增，直到 `count` 达到 5。

```c
int count = 0;
while (count < 5)
{
    printf("count = %d\n", count);
    count++;
}
```

**输出示例**：

```
while 循环:
count = 0
count = 1
count = 2
count = 3
count = 4
```

### 示例7：`do-while` 循环

`do-while` 循环与 `while` 循环的主要区别在于：`do-while` 循环在检查条件之前会先执行一次循环体中的代码。这意味着即使条件最初为假，循环体也至少会执行一次。该示例中，`count` 从 `0` 开始，`do-while` 循环会先输出 `count` 的值，然后在每次迭代后将其递增，直到 `count` 达到5为止。

```c
do
{
    printf("count = %d\n", count);
    count++;
} while (count < 5);
```

**输出示例**：

```
do-while 循环:
count = 0
count = 1
count = 2
count = 3
count = 4
```

- **特点**：即使初始条件不满足，循环体也会执行一次。这对于需要至少执行一次操作的场景非常有用。

### 示例8：`for` 循环

`for` 循环通常用于已知迭代次数的场景。在该示例中，`for` 循环控制变量 `i` 从 0 递增到 4，每次循环都输出当前的 `i` 值。

```c
for (int i = 0; i < 5; i++)
{
    printf("i = %d\n", i);
}
```

**输出示例**：

```
for 循环:
i = 0
i = 1
i = 2
i = 3
i = 4
```

- **特点**：`for` 循环包括三个部分：初始化表达式、条件表达式、和递增/递减表达式。它非常适合用于固定次数的迭代任务。

### 示例9：`for` 循环 - 多个变量

`for` 循环允许同时操作多个变量。该示例中，`i` 从 0 递增，而 `j` 从 10 递减，每次迭代时都会输出这两个变量的值。

```c
for (int i = 0, j = 10; i < 5; i++, j--)
{
    printf("i = %d, j = %d\n", i, j);
}
```

**输出示例**：

```
for 循环 - 多个变量:
i = 0, j = 10
i = 1, j = 9
i = 2, j = 8
i = 3, j = 7
i = 4, j = 6
```

- **特点**：可以在 `for` 循环中同时控制多个变量，适合需要同步变化的任务。

### 示例10：`break` 语句

`break` 语句用于立即终止循环，不论循环条件是否仍为真。当 `i` 等于 5 时，`break` 语句会终止循环，剩下的循环体不会被执行。

```c
for (int i = 0; i < 10; i++)
{
    if (i == 5)
    {
        break; // 当 i 等于 5 时退出循环
    }
    printf("i = %d\n", i);
}
```

**输出示例**：

```
break 语句:
i = 0
i = 1
i = 2
i = 3
i = 4
```

- **特点**：`break` 语句可用于退出当前循环或 `switch` 语句，特别适用于在特定条件下提前退出的场景。

### 示例11：`continue` 语句

`continue` 语句会跳过当前迭代中的剩余代码，并直接进入下一次迭代。在此示例中，当 `i` 是偶数时，`continue` 语句会跳过 `printf` 的执行，输出只包括奇数的值。

```c
for (int i = 0; i < 10; i++)
{
    if (i % 2 == 0)
    {
        continue; // 跳过偶数
    }
    printf("i = %d\n", i);
}
```

**输出示例**：

```
continue 语句:
i = 1
i = 3
i = 5
i = 7
i = 9
```

- **特点**：`continue` 语句跳过当前循环的剩余部分，适合需要有选择地执行某些循环体操作的情况。

### 示例12：嵌套循环

嵌套循环是指一个循环内部包含另一个循环。在该示例中，外层循环控制 `i`，内层循环控制 `j`，每次外层循环迭代时，内层循环会执行完整的循环。每次内外循环的迭代都会输出当前的 `i` 和 `j` 值。

```c
for (int i = 1; i <= 3; i++)
{
    for (int j = 1; j <= 3; j++)
    {
        printf("i = %d, j = %d\n", i, j);
    }
}
```

**输出示例**：

```
嵌套循环:
i = 1, j = 1
i = 1, j = 2
i = 1, j = 3
i = 2, j = 1
i = 2, j = 2
i = 2, j = 3
i = 3, j = 1
i = 3, j = 2
i = 3, j = 3
```

- **特点**：嵌套循环常用于处理多维数据结构（如二维数组）或需要对不同维度进行遍历的情况。

### 示例13：循环中的条件判断和 `break` 语句结合

在这个示例中，`for` 循环遍历 `i` 从 0 到 9，每次迭代时都会输出 `i` 的值。当 `i` 大于 5 时，会触发 `if` 条件，然后输出 `i 大于 5，退出循环`，并使用 `break` 语句结束循环。`break` 语句可以立即终止循环，不再执行剩余的迭代。

```c
for (int i = 0; i < 10; i++)
{
    printf("i = %d\n", i);
    if (i > 5)
    {
        printf("i 大于 5，退出循环\n");
        break;
    }
}
```

**输出示例**：

```
循环中的条件判断和 break 语句结合:
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i 大于 5，退出循环
```

- **要点**：`break` 可用于在满足特定条件时终止循环，避免不必要的迭代。

### 示例14：嵌套的条件和循环结构

该示例展示了在循环内部嵌套条件判断和另一个循环。外层循环遍历 `i` 从 0 到 2，当 `i` 为偶数时，内层循环运行，并输出内外层循环变量 `i` 和 `j` 的值。

```c
for (int i = 0; i < 3; i++)
{
    if (i % 2 == 0)
    {
        for (int j = 0; j < 3; j++)
        {
            printf("i = %d, j = %d\n", i, j);
        }
    }
}
```

**输出示例**：

```
嵌套的条件和循环结构:
i = 0, j = 0
i = 0, j = 1
i = 0, j = 2
i = 2, j = 0
i = 2, j = 1
i = 2, j = 2
```

- **要点**：嵌套条件和循环常用于复杂的逻辑，比如多层次的数据处理。`if` 和 `for` 结合，可以根据条件灵活控制嵌套循环的执行。

### 示例15：`switch` 中的嵌套结构

此示例展示了如何在 `switch` 语句中嵌套另一个 `switch`。根据 `x` 的值选择外层 `switch` 的分支，当 `x` 为 2 时，内层 `switch` 再根据 `y` 的值输出相应的结果。

```c
int x = 2, y = 3;
switch (x)
{
    case 1:
        printf("x 是 1\n");
        break;
    case 2:
        switch (y)
        {
        case 2:
            printf("y 是 2\n");
            break;
        case 3:
            printf("y 是 3\n");
            break;
        }
        break;
    default:
        printf("x 不是 1 或 2\n");
        break;
}
```

**输出示例**：

```
switch 中的嵌套结构:
y 是 3
```

- **要点**：嵌套 `switch` 可以用于处理多层次的条件判断，适合有多个条件依赖关系的场景。

### 示例16：带标签的 `goto` 语句

`goto` 语句是C语言中跳转控制流的一种方式。该示例展示了当条件满足时，程序将跳转到标签 `label` 处并继续执行。需要注意的是，`goto` 语句通常不建议使用，因为它会使代码结构不清晰，难以维护。

```c
int flag = 1;
if (flag)
{
    goto label;
}
printf("这行代码不会执行\n");
label:
    printf("跳到了标签处\n");
```

**输出示例**：

```
goto 语句:
跳到了标签处
```

- **要点**：`goto` 可以实现跳转控制流，但它会降低代码的可读性和可维护性，应尽量避免使用。

### 示例17：`for` 循环中的空语句

该示例展示了 `for` 循环中的空语句。在这段代码中，`for` 循环的循环体为空，但通过循环控制表达式累加了 `sum` 的值。最终输出从 1 到 100 的累加和。

```c
int sum = 0;
for (int i = 1; i <= 100; sum += i, i++)
    ; // 空语句
printf("1 到 100 的和是: %d\n", sum);
```

**输出示例**：

```
for 循环中的空语句:
1 到 100 的和是: 5050
```

- **要点**：空语句有时用于简化代码逻辑，可以在循环控制部分执行所有的操作，但应确保代码易于理解。

### 示例18：嵌套循环 - 打印乘法表

该示例使用嵌套循环打印9x9的乘法表。外层循环控制行数（乘数），内层循环控制列数（被乘数），每次输出当前的乘法运算结果。`%2d` 用于确保结果的格式对齐。

```c
for (int i = 1; i <= 9; i++)
{
    for (int j = 1; j <= i; j++)
    {
        printf("%d * %d = %2d  ", j, i, i * j);
    }
    printf("\n");
}
```

**输出示例**：

```
嵌套循环 - 打印乘法表:
1 * 1 =  1  
1 * 2 =  2  2 * 2 =  4  
1 * 3 =  3  2 * 3 =  6  3 * 3 =  9  
1 * 4 =  4  2 * 4 =  8  3 * 4 = 12  4 * 4 = 16  
1 * 5 =  5  2 * 5 = 10  3 * 5 = 15  4 * 5 = 20  5 * 5 = 25  
1 * 6 =  6  2 * 6 = 12  3 * 6 = 18  4 * 6 = 24  5 * 6 = 30  6 * 6 = 36  
1 * 7 =  7  2 * 7 = 14  3 * 7 = 21  4 * 7 = 28  5 * 7 = 35  6 * 7 = 42  7 * 7 = 49  
1 * 8 =  8  2 * 8 = 16  3 * 8 = 24  4 * 8 = 32  5 * 8 = 40  6 * 8 = 48  7 * 8 = 56  8 * 8 = 64  
1 * 9 =  9  2 * 9 = 18  3 * 9 = 27  4 * 9 = 36  5 * 9 = 45  6 * 9 = 54  7 * 9 = 63  8 * 9 = 72  9 * 9 = 81  
```

- **要点**：嵌套循环非常适合生成多维输出，特别是在需要遍历矩阵或表格时。

### 示例19：带标志的跳出多层嵌套循环

在这个示例中，我们通过一个标志变量 `found` 来实现从多层嵌套循环中跳出。当满足 `i == 3 && j == 3` 条件时，设置 `found` 为 1，并用 `break` 语句跳出内层循环。随后外层循环检测 `found` 变量的值，如果为真，则也退出外层循环。通过这种方式，可以从多层嵌套循环中安全退出，而不需要使用复杂的控制结构。

```c
int found = 0; // 标志变量
for (i = 1; i <= 5; i++) {
    for (j = 1; j <= 5; j++) {
        if (i == 3 && j == 3) {
            found = 1; // 设置标志
            break;     // 跳出内层循环
        }
        printf("i = %d, j = %d\n", i, j);
    }
    if (found) { // 外层循环检测标志
        break;
    }
}
```

**输出示例**：

```
带标志的跳出多层嵌套循环:
i = 1, j = 1
...
i = 3, j = 2
i 大于 5，退出循环
```

- **要点**：通过标志变量与 `break` 语句相结合，可以灵活控制嵌套循环的退出。

### 示例20：模拟 `switch` 的枚举与函数指针表

在这个示例中，使用枚举 `enum` 来定义不同的操作，并使用函数指针数组来调用相应的函数。这种方法模拟了 `switch-case` 结构，但通过函数指针实现更灵活的操作分发。在函数指针数组 `operations[]` 中，每个元素对应一个算术操作（加、减、乘、除），可以根据枚举类型来选择合适的函数调用。

```c
int (*operations[])(int, int) = {add, subtract, multiply, divide}; // 函数指针数组

int op = ADD;
int x1 = 10, y1 = 5;
printf("ADD: %d + %d = %d\n", x1, y1, operations[op](x1, y1));

op = MULTIPLY;
printf("MULTIPLY: %d * %d = %d\n", x1, y1, operations[op](x1, y1));
```

**输出示例**：

```
模拟 switch 的枚举与函数指针表:
ADD: 10 + 5 = 15
MULTIPLY: 10 * 5 = 50
```

- **要点**：枚举和函数指针数组组合使用能够实现类似 `switch` 的功能，灵活处理多种操作类型。

### 示例21：`if` 语句中的逗号运算符

在 C 语言中，逗号运算符允许在一条语句中执行多个操作。此示例展示了在 `if` 语句中使用逗号运算符，`a1 = 3, b1 = 4` 会首先赋值，然后根据 `a1 > b1` 的结果执行相应的条件分支。

```c
if (a1 = 3, b1 = 4, a1 > b1) {
    printf("a1 大于 b1\n");
} else {
    printf("a1 小于或等于 b1\n");
}
```

**输出示例**：

```
if 语句中的逗号运算符:
a1 小于或等于 b1
```

- **要点**：逗号运算符可以在单个表达式中执行多个操作，但需要注意其优先级，通常在复杂表达式中使用时需要特别小心。

### 示例22：在循环内动态调整循环条件

该示例展示了在循环过程中动态调整循环条件的情况。最初 `limit` 设为 5，但当 `i == 2` 时，`limit` 被修改为 7，这样会使循环运行更多的迭代。

```c
int limit = 5;
for (int i = 0; i < limit; i++) {
    printf("i = %d\n", i);
    if (i == 2) {
        limit = 7; // 在循环中动态调整 limit
        printf("Limit 动态调整为 %d\n", limit);
    }
}
```

**输出示例**：

```
在循环内动态调整循环条件:
i = 0
i = 1
i = 2
Limit 动态调整为 7
i = 3
i = 4
i = 5
i = 6
```

- **要点**：可以在循环内动态调整循环的条件，使得循环能够根据运行时的状态变化。

### 示例23：多层循环中的 `continue` 和 `break`

在这个示例中，`continue` 和 `break` 语句结合使用。在嵌套的循环中，当 `i == j` 时，使用 `continue` 跳过当前迭代。当 `i + j == 4` 时，使用 `break` 退出内层循环。

```c
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == j) {
            continue; // 跳过同等 i, j 的情况
        }
        if (i + j == 4) {
            break; // 当 i + j 等于 4 时，跳出内层循环
        }
        printf("i = %d, j = %d\n", i, j);
    }
}
```

**输出示例**：

```
多层循环中的 continue 和 break:
i = 0, j = 1
i = 0, j = 2
i = 1, j = 0
i = 1, j = 2
i = 2, j = 0
i = 2, j = 1
```

- **要点**：`continue` 和 `break` 语句结合使用，能够灵活控制循环的执行，尤其在嵌套循环中。

### 示例24：`for` 循环中的条件初始化

此示例展示了如何在 `for` 循环的初始化部分使用多个变量，同时通过条件控制循环的终止。`sum` 变量随着 `i` 的增加而不断累加，当 `sum >= 20` 或者 `i >= 10` 时，循环终止。

```c
for (int i = 0, sum = 0; i < 10 && sum < 20; i++) {
    sum += i;
    printf("i = %d, sum = %d\n", i, sum);
}
```

**输出示例**：

```
for 循环中的条件初始化:
i = 0, sum = 0
i = 1, sum = 1
i = 2, sum = 3
i = 3, sum = 6
i = 4, sum = 10
i = 5, sum = 15
i = 6, sum = 21
```

- **要点**：在 `for` 循环的初始化和条件部分，可以同时控制多个变量和条件，增加了循环的灵活性和可控性。

### 示例25：条件编译中的控制结构

条件编译用于根据编译时的配置执行不同的代码块。在这个示例中，`#ifdef DEBUG` 和 `#else` 用来选择执行不同的代码块。如果在编译时定义了 `DEBUG` 宏，则执行 `Debug` 模式下的代码；否则，执行 `Release` 模式下的代码。这种控制结构非常适合调试和发布版本之间的切换。

```c
#ifdef DEBUG
    printf("Debug 模式下执行的代码\n");
#else
    printf("Release 模式下执行的代码\n");
#endif
```

**输出示例**：
（如果未定义 `DEBUG` 宏）

```
Release 模式下执行的代码
```

- **要点**：条件编译常用于调试与优化、平台依赖的代码分支处理等情况。

### 示例26：使用 `assert` 检查控制结构中的逻辑

`assert` 是一种用于调试的宏，可以在运行时验证某个条件是否为真。如果条件为假，程序将终止并输出错误信息。这个示例中，`assert(val >= 0)` 会检查 `val` 是否大于或等于 0，如果不满足条件，程序终止。

```c
int val = 10;
assert(val >= 0); // 如果 val 小于 0，程序终止
printf("val = %d\n", val);
```

**输出示例**：

```
使用 assert 检查控制结构中的逻辑:
val = 10
```

- **要点**：`assert` 常用于检测运行时的假设条件，尤其在调试阶段可以帮助捕捉逻辑错误。

### 示例27：条件循环与函数结合

此示例展示了如何将循环和函数结合使用。`check_condition` 函数检查输入是否大于 0，`while` 循环依赖该函数的返回值来控制是否继续迭代。每次循环中，`start` 值减少，直到不再满足条件为止。

```c
int start = 5;
while (check_condition(start))
{
    printf("start = %d\n", start);
    start--;
}
```

**输出示例**：

```
条件循环与函数结合:
start = 5
start = 4
start = 3
start = 2
start = 1
```

- **要点**：通过将条件判断封装在函数中，可以使代码逻辑更清晰，并复用相同的检查逻辑。

### 示例28：使用 `for` 循环计算数组元素的和

此示例展示了如何使用 `for` 循环遍历数组并计算数组元素的和。通过 `sizeof(arr) / sizeof(arr[0])` 计算数组长度，确保程序不会越界访问。

```c
int arr[] = {1, 2, 3, 4, 5};
int sum1 = 0;
for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
{
    sum1 += arr[i];
}
printf("数组元素的和: %d\n", sum1);
```

**输出示例**：

```
使用 for 循环计算数组元素的和:
数组元素的和: 15
```

- **要点**：使用 `sizeof` 计算数组长度是确保不越界访问数组的有效方法。

### 示例29：倒序循环遍历数组

通过 `for` 循环的倒序遍历，可以从数组的最后一个元素开始遍历到第一个元素。这种方式在需要从后向前处理数据时很有用。

```c
for (int i = sizeof(arr) / sizeof(arr[0]) - 1; i >= 0; i--)
{
    printf("arr[%d] = %d\n", i, arr[i]);
}
```

**输出示例**：

```
倒序循环遍历数组:
arr[4] = 5
arr[3] = 4
arr[2] = 3
arr[1] = 2
arr[0] = 1
```

- **要点**：倒序遍历数组可以用于需要逆序处理数据的场景。

### 示例30：双重循环中跳出到外层

1. **方式1：使用标志变量退出多层循环**
   通过标志变量 `found1` 来记录何时需要退出循环。当 `j == 3` 时，设置 `found1 = 1` 并使用 `break` 退出内层循环，然后在外层循环检查标志变量的值。

```c
int found1 = 0; // 标志变量
for (int i = 0; i < 5 && !found1; i++)
{
    for (int j = 0; j < 5; j++)
    {
        if (j == 3)
        {
            found1 = 1; // 设置标志变量，退出外层循环
            break;      // 跳出内层循环
        }
        printf("i = %d, j = %d\n", i, j);
    }
}
```

2. **方式2：使用 `goto` 跳出双重循环**
   通过 `goto` 语句可以直接跳出多层循环，使用时要小心，尽量避免过度使用 `goto`，因为它会使代码逻辑变得不清晰。

```c
for (int i = 0; i < 5; i++)
{
    for (int j = 0; j < 5; j++)
    {
        if (j == 3)
        {
            goto outer_loop_exit; // 使用 goto 跳出双重循环
        }
        printf("i = %d, j = %d\n", i, j);
    }
}
outer_loop_exit:
    printf("跳出了双重循环\n");
```

**输出示例**：

```
双重循环中使用标志位跳出外层:
i = 0, j = 0
i = 0, j = 1
i = 0, j = 2
i = 1, j = 0
i = 1, j = 1
i = 1, j = 2
i = 2, j = 0
i = 2, j = 1
i = 2, j = 2

双重循环中使用 goto 跳出外层:
i = 0, j = 0
i = 0, j = 1
i = 0, j = 2
跳出了双重循环
```

- **要点**：
  - 使用标志变量可以确保逻辑清晰且易于维护。
  - `goto` 虽然能直接跳出多层循环，但应尽量少用，避免降低代码可读性。

### 示例20函数定义

在示例20中，定义了几个基本的算术操作函数（`add`、`subtract`、`multiply`、`divide`），以及一个用于检查条件的函数 `check_condition`。这些函数的定义可以与函数指针结合使用，形成一种灵活的操作选择机制，比如模拟 `switch` 语句的操作选择。

#### 1. `add` 函数

`add` 函数接收两个整型参数 `a` 和 `b`，返回它们的和。

#### 2. `subtract` 函数

`subtract` 函数用于执行减法操作，返回 `a - b` 的值。

#### 3. `multiply` 函数

`multiply` 函数接收两个整型参数，返回它们的乘积。

#### 4. `divide` 函数

`divide` 函数执行除法操作，但增加了一个简单的安全检查。为了避免除数为0的情况，函数会在 `b != 0` 的前提下执行除法操作。如果 `b` 为0，则返回0。

- **返回值**：
  - 如果 `b != 0`，返回 `a / b`。
  - 如果 `b == 0`，返回0，以防止除以0的错误。

#### 5. `check_condition` 函数

`check_condition` 函数用于判断给定的整数 `num` 是否大于0。如果 `num > 0`，函数返回1（真）；否则返回0（假）。这个函数通常用于控制循环中的条件判断。

```c
int check_condition(int num)
{
    return num > 0;
}
```

- **作用**：检查数字是否大于0。
- **返回值**：
  - 如果 `num > 0`，返回1。
  - 如果 `num <= 0`，返回0。
