# 三. 编写启动代码

编写启动代码是裸机编程的一个关键步骤，涉及到许多底层细节，这些细节确保了程序能够在没有操作系统支持的环境下运行。以下是编写启动代码时的基础必需步骤和更高层次的可选步骤。

### 启动流程的关键组成部分

#### 1. **启动入口和初始化代码（必需）**

这是程序启动时首先执行的代码部分，通常用**汇编语言**编写（如`entry.asm`），该入口点是程序开始执行的第一个位置。这是必须的，因为它负责将控制权从硬件转移到我们的软件中。

- **启动入口点**：程序的执行开始处，通常命名为`_start`。在RISC-V架构下，这个入口点的任务包括初始化寄存器（尤其是堆栈指针SP），为程序运行准备必要的环境。
- **初始化寄存器和栈**：确保所有需要的寄存器都被正确初始化，特别是设置堆栈指针，以便程序能够使用堆栈。
- **清零.bss段**：将未初始化的数据段（.bss段）清零，保证全局和静态变量在使用前被初始化为零。

#### 2. **内核入口和内存布局（必需）**

涉及到如何组织程序的内存布局，以及如何从启动代码跳转到主程序（比如Rust编写的内核或应用）。

- **内存布局**：通过**链接脚本**（如`linker.ld`或`memory.x`）定义，它指定了不同程序段（如.text, .data, .bss）的位置及大小。这对于确保程序能正确地加载到内存中执行至关重要。
  - **`memory.x`文件**：通常用于简化的内存布局定义。在Rust项目中，这个文件指定了如堆、栈、代码和数据段等的内存布局。
  - **`linker.ld`文件**：提供了更复杂和详细的链接配置，比`memory.x`更加强大和灵活。它可以控制各种内存段的具体位置、大小，以及特殊的链接需求。

- **内核入口**：启动代码在完成所有必要的初始化后，需要跳转到内核的主入口点，这通常是一个用Rust编写的`main`函数。

### 可选或高层次设计步骤

#### 1.**处理特权级和系统调用**

- 在设计需要运行在不同特权级上的系统时，启动代码需要设置和管理CPU的特权级。实现和封装系统调用接口（比如通过SBI），允许软件执行特权操作。
- 在RISC-V架构下，**SBI**（Supervisor Binary Interface）为操作系统提供了一种方式来执行特权级操作，比如中断管理或I/O操作，而不需要直接执行硬件特定的代码。

  - **SBI的角色**：如果你的系统设计包括运行在S模式下的操作系统，那么在启动阶段初始化SBI环境是必需的。这通常涉及到使用已经存在的SBI实现（如OpenSBI或RustSBI），并在启动代码中进行配置以使用这些服务。
  - **实践细节**：涉及到如何将SBI实现集成到你的启动流程中，可能包括加载SBI实现的二进制到适当的内存位置，以及设置寄存器以便于操作系统启动后能调用SBI提供的功能。

#### **2.异常和中断处理**

- 初始化和配置异常及中断处理程序。这对于创建能够响应硬件事件和异常情况的系统至关重要。
- 在更复杂的系统或操作系统中，这些步骤是必需的，以保证系统的稳定性和响应性。

#### 3.**组织和实现**

- **构建脚本**（可选）：使用如Makefile或Cargo的构建脚本来自动化编译、链接和生成最终的可执行镜像过程。这包括调用编译器、链接器以及可能的其他工具（如`objcopy`）。
- **功能实现与封装**：在Rust代码中实现操作系统的核心功能和抽象，如中断处理、设备驱动接口和系统调用。这些通常以模块化的方式实现，并在内核的主逻辑中被调用。

### 总结

- **基础步骤**确保了程序能够在裸机上正确启动并跳转到主逻辑进行执行。这些步骤适用于几乎所有裸机项目，无论项目复杂度如何。
- **`memory.x`和`linker.ld`**的选择取决于项目需求：对于简单项目，`memory.x`可能足够；而对于需要详细控制内存布局和链接过程的复杂项目，`linker.ld`提供了更多的灵活性和控制力。
- **高层次的可选步骤**增加了对复杂硬件交互的支持，特别是在设计操作系统或需要精细控制硬件特性的高级应用时。这些步骤可以根据项目的具体需求和目标来决定是否实现。

---

## 展开讲解

### 1.**启动入口和初始化代码（必需）**

在裸机编程中，尤其是针对RISC-V架构，启动入口和初始化代码阶段是至关重要的，因为它为程序的其余部分设置了必要的运行环境。这一阶段主要使用汇编语言编写，因为它需要直接与硬件交互。以下是这一阶段涉及的关键知识点和包含的内容：

#### 启动入口点定义 (_start)

- **入口点(_start)**：这是程序的第一执行点，也是系统加电或重置后CPU首先执行的地方。对于RISC-V来说，通常在链接脚本中指定`_start`为入口点，确保在生成的二进制文件中，`_start`位于预期的地址。
- **内容**：`_start`会包含最初的汇编指令，用于设置程序运行的初始状态。这包括寄存器初始化、堆栈指针设置等。

#### 初始化寄存器和堆栈

- **堆栈指针(SP)**：堆栈是函数调用、局部变量存储等的关键区域。在`_start`中，第一个任务通常是设置堆栈指针（SP），指向一个足够大且合适的内存区域，用作程序的堆栈。
- **全局指针(GP)**：对于RISC-V，还可能需要设置全局指针（GP），这对于高效访问全局变量和静态数据很有用。
- **其他寄存器**：根据具体需求，可能还需要初始化其他寄存器，为程序运行做好准备。

#### 清零.bss段

- **.bss段清零**：`.bss`段包含了未初始化的全局变量和静态变量，按照C和UNIX的传统，这些变量在程序开始执行前应该被清零。在`_start`中，通常会有一小段代码遍历`.bss`段的所有地址，将其设置为0。
- **实现方式**：通过汇编循环操作，计算`.bss`段的起始地址和大小（这些信息可以从链接脚本获取），然后遍历这个范围，将每个位置清零。

#### 跳转到高级语言编写的入口（如Rust的main函数）

- **跳转指令**：完成基础设置后，`_start`将通过跳转指令转移到高级语言编写的程序入口点，比如Rust的`main`函数。这个转移标志着从汇编语言到高级语言的过渡，进入程序的主逻辑部分。
- **准备参数**：如果高级语言的入口点（如`main`）期望接收参数（例如命令行参数），在跳转前，需要按照约定在寄存器或内存中准备这些参数。

#### 汇编代码示例

一个非常基础的RISC-V启动汇编代码示例可能包括：

```assembly
.section .text
.global _start

_start:
    # 初始化堆栈指针
    la sp, stack_top

    # 清零.bss段（示例中未显示具体实现）

    # 跳转到主程序（Rust的main函数）
    call main

    # 循环或停机
    .align 2
    j .

.section .bss
    .align 4
stack:
    .space 4096  # 分配4096字节作为堆栈
stack_top:
```

这只是一个简化的例子，实际上，根据你的具体需求，可能还需要包括其他初始化操作。

启动入口和初始化代码阶段是裸机编程中至关重要的一步，涉及到与硬件紧密相关的低级设置。通过汇编语言直接控制硬件，为程序的其余部分提供了稳定的运行环境。理解和正确实现这一阶段是后续开发工作顺利进行的基础。

### 2.**内核入口和内存布局（必需）**

内核入口和内存布局是操作系统或裸机程序启动过程中的关键阶段，涉及到如何组织和安排程序在内存中的布局。这一阶段的核心工作是通过链接脚本来完成，它为编译器和链接器提供了如何将程序的各个部分放置到内存中的指示。

### 链接脚本（Linker Script）

链接脚本是一种特殊的脚本文件，用于控制程序的内存布局。它定义了各个段（如.text, .data, .bss等）的位置、大小以及它们在最终二进制文件中的排列方式。

#### 关键概念和组件

- **.text段**：存放程序的执行代码。在链接脚本中，你需要指定代码段的位置，这通常是程序的起始点。
- **.data段**：包含已初始化的全局变量和静态变量。这些变量在程序启动前由加载器放置在指定位置。
- **.bss段**：用于未初始化的全局变量和静态变量，这部分在程序启动时通常被清零。
- **堆（heap）和栈（stack）**：虽然堆和栈的具体位置和大小可以在运行时动态调整，但在某些情况下，链接脚本也可能用于指定它们的初始位置和大小限制。

#### 示例链接脚本内容

```ld
/* Define the memory regions where program sections will be placed */
MEMORY
{
    RAM (wxa) : ORIGIN = 0x80000000, LENGTH = 128K
}

/* Define the program sections */
SECTIONS
{
    /* .text section */
    .text : {
        *(.text)
    } > RAM

    /* .data section */
    .data : {
        *(.data)
    } > RAM

    /* .bss section */
    .bss : {
        *(.bss)
        *(.sbss)
    } > RAM

    /* Add additional sections here */
}
```

这个示例中，我们定义了一个名为`RAM`的内存区域，起始地址为`0x80000000`，长度为128K。然后，我们指定了.text、.data和.bss段应该被放置在`RAM`区域。链接脚本的这种配置确保了程序的不同部分按照预期的方式被放置在内存中。

### 内核入口点

内核入口点是操作系统启动流程中的一个关键概念，是操作系统或裸机应用程序开始执行的地方。在链接脚本中，可以通过指定入口点符号（通常是`_start`）来明确这一点。

- **设置入口点**：在链接脚本中，使用`ENTRY(_start)`指令来指定入口点。这告诉链接器程序执行应该从`_start`标签的位置开始。
- **入口点函数**：对于由Rust编写的程序，入口点函数可能是Rust的`main`函数。汇编代码中的`_start`函数负责执行所有必要的初始化（如寄存器和堆栈设置），然后跳转到Rust的`main`函数。

内核入口和内存布局阶段对于确保程序能够正确加载和执行至关重要。通过精心设计的链接脚本，开发者可以详细控制程序的内存布局，以及如何将程序的不同部分安排在适当的内存区域中。这一阶段的成功完成为程序的顺利执行奠定了基础。理解和正确应用链接脚本的指令和语法，对于开发可靠的操作系统和裸机程序来说是非常重要的。

### 3.可选或高层次设计步骤

在开发基于RISC-V的操作系统或裸机程序时，除了必需的启动入口和内存布局设置之外，还有一系列可选或高层次设计步骤。这些步骤为操作系统提供了处理特权级和系统调用、异常和中断处理的能力，同时也包括了如何通过构建脚本自动化构建过程以及如何组织和实现操作系统的高级特性。

### 处理特权级和系统调用（SBI）

RISC-V架构定义了几个不同的特权级别，最常见的是机器模式（M模式）、监督者模式（S模式）和用户模式（U模式）。在更复杂的系统中，如操作系统，处理这些特权级别变得非常重要。

- **特权级切换**：启动代码需要将CPU从机器模式（M模式，最高权限级别）切换到监督者模式（S模式）或用户模式（U模式），以便正常运行操作系统或用户程序。这涉及到设置相关的控制寄存器和特权级状态。

- **系统调用接口（SBI）**：SBI允许S模式的软件调用M模式的功能，如中断管理、定时器设置等。在启动阶段或操作系统初始化阶段，确保SBI正确设置是至关重要的。对于使用Rust的项目，可能会用到如RustSBI这样的库来提供SBI功能。

### 异常和中断处理

异常和中断处理是操作系统核心功能之一，负责响应硬件事件和异常情况。

- **异常处理程序（trap handler）**：需要在系统初始化阶段注册异常处理程序，以便系统能够响应各种异常（如系统调用、页故障等）和中断（如外设中断）。

- **中断向量表**：在某些设计中，可能会使用中断向量表来管理不同的中断源和对应的处理程序。这通常涉及到内存布局的设计和特权级控制。

### 构建脚本（可选）

为了自动化和简化构建过程，使用构建脚本非常重要。这些脚本可以自动化编译、链接、生成二进制镜像等步骤。

- **Makefile或Cargo脚本**：对于Rust项目，Cargo已经提供了强大的构建管理功能。但在涉及到复杂的构建步骤或需要特定构建工具链时（如交叉编译），可能需要编写Makefile或扩展Cargo构建脚本。

### 功能实现与封装

随着系统功能的增加，适当地组织和封装代码变得尤为重要。

- **模块化设计**：将系统功能划分为不同的模块或库，例如内存管理、文件系统、网络堆栈等。这有助于提高代码的可读性和可维护性。

- **抽象和接口定义**：定义清晰的接口和抽象层，以隔离硬件相关的代码和上层的应用逻辑。这样可以更容易地在不同的硬件平台上移植和适配代码。

这些可选或高层次设计步骤使得操作系统能够有效地管理硬件资源，提供丰富的系统服务，并确保系统的可扩展性和可维护性。通过合理的组织代码和利用自动化构建脚本，可以提高开发效率，减少错误，并促进团队协作。这些高级特性和设计考虑是构建现代操作系统和复杂裸机程序不可或缺的部分。

---

## 补充1：第一章代码树结构解释

项目结构和文件解释如下，以及它们是如何在裸机或操作系统项目中协同工作的：

```python
.
├── bootloader
│   └── rustsbi-qemu.bin      # RISC-V的SBI实现，用于提供标准的系统调用接口
├── os
│   ├── Cargo.toml            # Rust项目配置文件，定义项目依赖和元数据
│   ├── Makefile              # 提供构建脚本，用于编译、链接和构建最终的二进制文件
│   └── src
│       ├── console.rs        # 封装打印字符的SBI接口，提供格式化输出功能
│       ├── entry.asm         # 裸机程序的汇编入口点，设置内核执行环境
│       ├── lang_items.rs     # 实现Rust特定的语义项，如panic处理逻辑
│       ├── linker.ld         # 链接脚本，定义内核的内存布局
│       ├── logging.rs        # 实现日志功能，用于调试和输出日志信息
│       ├── main.rs           # 内核的主函数，程序的主要入口点
│       └── sbi.rs            # 封装SBI调用的Rust接口，提供系统调用功能
└── rust-toolchain            # 指定Rust工具链的版本，确保编译一致性
```

### 流程和配合

1. **启动与SBI（Supervisor Binary Interface）**：
   - `bootloader/rustsbi-qemu.bin`是启动过程的关键，提供了SBI实现。SBI是RISC-V架构下，操作系统和硬件之间的接口标准，允许OS执行特权操作（如中断管理）而不直接与硬件交互。在系统启动时，这个二进制文件被加载执行，为操作系统提供必要的底层支持。

2. **项目配置**：
   - `Cargo.toml`定义了项目的依赖和编译配置，是使用Cargo构建Rust项目的标准方式。
   - `rust-toolchain`指定了项目使用的Rust版本，确保所有开发者和环境中的一致性。

3. **构建脚本**：
   - `Makefile`提供了构建命令，用于编译、链接和生成最终的二进制文件。它可能会调用`cargo build`以及其他工具，如`objcopy`将编译产物转换为特定格式。

4. **内核入口和内存布局**：
   - `entry.asm`包含启动代码的汇编入口点，它设置了程序的初步执行环境，如堆栈指针初始化，然后跳转到Rust的主函数`main.rs`开始执行。
   - `linker.ld`定义了程序的内存布局，包括代码、数据、堆栈等的位置和大小，这对于裸机编程至关重要。

5. **功能实现与封装**：
   - `main.rs`是程序的主入口，调用其他模块完成具体任务。
   - `console.rs`、`logging.rs`和`sbi.rs`提供了操作系统运行过程中所需的基础功能，如控制台输出和系统调用。
   - `lang_items.rs`实现了Rust编译器期望由操作系统或运行时提供的特殊功能，例如`panic`时的处理逻辑。

### 总结

这个项目是一个RISC-V架构下的操作系统实现，使用Rust编写。它从汇编语言编写的启动代码开始执行，初始化硬件和执行环境，然后进入Rust编写的主程序。在这个过程中，操作系统通过SBI与硬件交互，执行必要的系统调用，如时钟管理和中断处理。各个组件和文件按照其职责和需要协同工作，共同构成了操作系统的完整功能。

---

### 补充2：启动代码流程图

1. **开始** [硬件层级]
   - 描述：系统加电或重置。
2. **定义启动入口点 (_start)** [汇编语言, 软件层级]
   - 文件：`entry.asm` (或类似文件)
   - 描述：定义系统的入口点，第一段执行的代码。
3. **初始化寄存器和堆栈** [汇编语言, 软件层级]
   - 文件：`entry.asm`
   - 描述：设置堆栈指针（SP）和必要寄存器。
4. **清零.bss段** [汇编语言, 软件层级]
   - 文件：`entry.asm`
   - 描述：将未初始化的数据区域清零。
5. **设置内存布局** [链接脚本, 软件层级]
   - 文件：`linker.ld` 或 `memory.x`
   - 描述：定义内存段位置和大小。
6. **跳转到高级语言入口点** [汇编语言 -> Rust/C/C++, 软件层级]
   - 文件：`entry.asm` 跳转到 `main.rs` 或 `main.c`
   - 描述：从汇编跳转到高级语言编写的程序入口。
7. **处理特权级和系统调用 (SBI)** [可选, Rust/C, 软件层级]
   - 文件：`sbi.rs` 或 `sbi.c`
   - 描述：初始化SBI，进行特权级切换。
8. **异常和中断处理** [可选, Rust/C/C++, 软件层级]
   - 文件：`interrupt.rs` 或 `interrupt.c`
   - 描述：注册异常处理和中断处理函数。
9. **构建和链接** [构建系统, 软件层级]
   - 工具：Makefile, Cargo.toml
   - 描述：自动化编译和链接过程。
10. **生成二进制镜像** [构建系统, 软件层级]
    - 工具：`objcopy`, Cargo build scripts
    - 描述：将编译后的代码转换为可执行的二进制镜像。
11. **加载和运行** [硬件/模拟器层级]
    - 描述：将二进制镜像加载到目标硬件或模拟器上执行。
12. **系统运行** [硬件/软件层级]
    - 描述：系统执行用户定义的高级语言程序。

---

## 补充3：实验指导书相关内容

在基于RISC-V和Rust进行裸机编程的通用流程中，实现批处理操作系统、特权级的切换，以及后续的内容如多道程序与分时多任务、地址空间、进程及进程管理、文件系统与I/O重定向、进程间通信、并发等，主要构建于**“编写主程序”阶段之后**的深入开发和功能扩展。

### 裸机启动过程

1. **启动参数配置**与**RustSBI作为BootLoader**：使用QEMU来模拟RISC-V 64计算机的启动，通过-bios参数加载BootLoader（如RustSBI），并通过-device参数加载内核二进制文件到指定物理地址，属于在目标平台上运行的准备工作。

### 编写启动代码

1. **入口函数(_start)与启动代码**：定义启动应用程序的入口点`_start`，进行初步环境设置（如清零.bss段），直接与硬件交互，准备运行环境。
2. **实现关机功能**：通过ecall指令调用RustSBI提供的SBI调用实现关机功能，展示如何在操作系统内部使用系统调用与BootLoader进行交互。
3. **配置程序内存布局**与**设置栈空间布局**：使用链接脚本来调整链接器行为，确保生成的可执行文件的内存布局符合预期，并通过汇编代码初始化操作系统的栈空间。

### 实现批处理操作系统

1. **加载和执行应用程序**：描述如何将应用程序的二进制镜像加载到预定的物理地址上，并使用`fence.i`指令清空i-cache，属于实现批处理操作系统的关键步骤。

### 实现特权级的切换

1. **特权级切换**：详细介绍如何在用户模式(U Mode)和监督模式(S Mode)之间进行切换，处理系统调用和异常。展示操作系统如何通过`ecall`指令调用RustSBI提供的服务，如关机。

### 编译与构建

1. **QEMU模拟与运行**：通过`qemu-system-riscv64`命令加载并运行编译后的应用程序，涉及使用链接脚本控制程序内存布局的细节。

### 扩展操作系统功能

1. **第二章至第八章内容**：这些章节覆盖了从批处理系统到并发的操作系统核心功能实现和性能提升的关键点，如多道程序与分时多任务、地址空间、进程及进程管理、文件系统与I/O重定向、进程间通信等，是在“编写主程序”阶段之后，根据操作系统设计的需要，逐步实现和完善的高级功能和特性。

### `memory.x` vs. `linker.ld`

> 之前提到过`link_riscv32.x` ,`link_riscv64.x` 和 `src/linker.ld` 都是链接脚本的示例。

- **`memory.x`文件**：这是一种在Rust嵌入式或裸机项目中常见的做法，特别是当使用`cargo`构建系统和`rustc`编译器时。`memory.x`通常用来指定内存布局，比如内存的起始地址和大小。它是链接器脚本的简化形式，专门用于配置内存，而这份配置会被嵌入式项目中的链接器所使用。
- **`linker.ld`文件**：这是更通用的链接器脚本文件，它不仅可以定义内存布局，还可以进行更复杂的链接指令，如符号重定位、段（section）的安排和属性设置等。`linker.ld`文件提供了更广泛和灵活的配置能力，适用于需要详细控制编译输出的项目。

---

## 补充4

### - 为什么选择`linker.ld`

在你提到的项目中，选择使用`linker.ld`而不是`memory.x`可能有以下几个原因：

1. **更复杂的内存布局**：如果项目需要详细定义多个内存段、特殊的符号或其他复杂的链接规则，`linker.ld`能够提供更丰富的语法和功能。
2. **更广泛的兼容性**：`linker.ld`作为GNU链接器的标准配置文件，可能被项目选择以确保与广泛使用的工具链和环境的兼容性，尤其是在不仅限于Rust生态的跨语言项目中。
3. **项目需求**：项目可能需要特定的配置，如加载地址、符号导出、分段安排等，这超出了`memory.x`的简化范畴。特别是在涉及到操作系统或复杂裸机程序时，对链接过程的精细控制变得非常重要。

尽管`memory.x`和`linker.ld`都可以用于配置项目的内存布局和链接过程，但`linker.ld`提供了更广泛的功能和灵活性。在某些情况下，选择`linker.ld`是出于对项目复杂度和特定需求的考虑。这种选择反映了项目的设计者根据其需求和偏好做出的决定。在你提到的这个项目中，使用`linker.ld`说明开发者可能需要利用到GNU链接器提供的高级功能，或者是出于与其他非Rust组件协作的需要。

---

### 相关词汇表

**基础概念**

- **汇编语言**：一种低级编程语言，与机器指令一一对应，用于编写与硬件直接交互的代码。
- **寄存器**：CPU内的小容量存储单元，用于存储指令、数据和地址等。
- **堆栈指针(SP)**：一个特定的寄存器，指向当前的栈顶位置。
- **全局指针(GP)**：用于高效访问全局变量的寄存器，主要在某些架构（如RISC-V）中使用。

**内存与程序结构**

- **堆（heap）**：动态分配的内存区域，用于存储程序运行时分配的数据。
- **栈（stack）**：自动管理的内存区域，用于存储局部变量和管理函数调用。
- **.text段**：程序的机器指令部分，存储编译后的代码。
- **.data段**：存储程序的已初始化全局变量和静态变量。
- **.bss段**：未初始化的全局和静态变量存储区域，通常在程序启动时清零。
- **内存布局**：程序在内存中的组织结构，包括.text、.data、.bss段以及堆和栈的位置。

**控制流与管理**

- **启动入口**：程序开始执行的第一个位置，通常是汇编语言编写的入口点`_start`。
- **跳转指令**：一种汇编指令，用于改变程序的执行流程。
- **内核入口**：操作系统开始执行的地方，从启动代码跳转到这里开始执行操作系统的主体。
- **特权级与特权级切换**：CPU的运行模式，决定了执行指令的权限。特权级切换是从一个运行模式切换到另一个运行模式的过程。
- **系统调用/SBI**：提供一种方式，允许用户空间的程序请求操作系统内核提供的服务。对于RISC-V，SBI（Supervisor Binary Interface）允许S模式下的代码调用M模式下的功能。
- **异常和中断处理**：对系统运行过程中出现的异常情况或外部中断事件的响应和处理。

**构建与封装**

- **链接脚本**：控制程序内存布局的脚本，定义了不同段的位置和顺序。
- **构建脚本**：用于自动化编译和构建过程的脚本，例如Makefile或Cargo的构建配置。
- **封装**：将代码模块化和抽象化的过程，使得功能分割清晰，便于管理和重用。
